{"ast":null,"code":"import _asyncToGenerator from \"/Users/kylenewins/Documents/The Moat/the_moat_io/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { isEmptyAccessToken } from \"../auth/IAuthStrategy.js\";\nexport default class GenericCache {\n  storage;\n  updateFunctions;\n  autoRenewInterval;\n  autoRenewWindow;\n\n  constructor(storage, updateFunctions = new Map(), autoRenewInterval = 0, autoRenewWindow = 2 * 60 * 1000 // Two minutes\n  ) {\n    this.storage = storage;\n    this.updateFunctions = updateFunctions;\n    this.autoRenewInterval = autoRenewInterval;\n    this.autoRenewWindow = autoRenewWindow;\n\n    if (this.autoRenewInterval > 0) {\n      setInterval(() => this.autoRenewRenewableItems(), this.autoRenewInterval);\n    }\n  }\n\n  getOrCreate(cacheKey, createFunction, updateFunction) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (updateFunction) {\n        _this.updateFunctions.set(cacheKey, updateFunction);\n      }\n\n      const item = yield _this.get(cacheKey);\n\n      if (item) {\n        return item;\n      }\n\n      const newCacheItem = yield createFunction();\n\n      if (!newCacheItem) {\n        throw new Error(\"Could not create cache item\");\n      }\n\n      if (!isEmptyAccessToken(newCacheItem)) {\n        _this.setCacheItem(cacheKey, newCacheItem);\n      }\n\n      return newCacheItem;\n    })();\n  }\n\n  get(cacheKey) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let asString = _this2.storage.get(cacheKey);\n\n      let cachedItem = asString ? JSON.parse(asString) : null;\n\n      if (_this2.itemDueToExpire(cachedItem) && _this2.updateFunctions.has(cacheKey)) {\n        const updateFunction = _this2.updateFunctions.get(cacheKey);\n\n        yield _this2.tryUpdateItem(cacheKey, cachedItem, updateFunction); // Ensure updated item is returned\n\n        asString = _this2.storage.get(cacheKey);\n        cachedItem = asString ? JSON.parse(asString) : null;\n      }\n\n      if (!cachedItem) {\n        return null;\n      }\n\n      if (cachedItem.expires && (cachedItem.expires === -1 || cachedItem.expires <= Date.now())) {\n        _this2.remove(cacheKey);\n\n        return null;\n      }\n\n      if (cachedItem.expiresOnAccess && cachedItem.expiresOnAccess === true) {\n        _this2.remove(cacheKey);\n\n        return cachedItem;\n      }\n\n      return cachedItem;\n    })();\n  }\n\n  set(cacheKey, value, expiresIn) {\n    const expires = Date.now() + expiresIn;\n    const cacheItem = { ...value,\n      expires\n    };\n    this.setCacheItem(cacheKey, cacheItem);\n  }\n\n  setCacheItem(cacheKey, cacheItem) {\n    const asString = JSON.stringify(cacheItem);\n    this.storage.set(cacheKey, asString);\n  }\n\n  remove(cacheKey) {\n    this.storage.remove(cacheKey);\n  }\n\n  itemDueToExpire(item) {\n    if (!item) {\n      return false;\n    }\n\n    if (!item.expires) {\n      return false;\n    }\n\n    return item.expires - Date.now() < this.autoRenewWindow;\n  }\n\n  autoRenewRenewableItems() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      _this3.updateFunctions.forEach( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (updateFunction, key) {\n          const cachedItem = yield _this3.get(key);\n\n          if (!cachedItem) {\n            return;\n          }\n\n          if (updateFunction && _this3.itemDueToExpire(cachedItem)) {\n            yield _this3.tryUpdateItem(key, cachedItem, updateFunction);\n          }\n        });\n\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n\n  tryUpdateItem(key, cachedItem, updateFunction) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const updated = yield updateFunction(cachedItem);\n\n        if (updated) {\n          _this4.setCacheItem(key, updated);\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    })();\n  }\n\n}","map":{"version":3,"sources":["/Users/kylenewins/Documents/The Moat/the_moat_io/node_modules/@spotify/web-api-ts-sdk/dist/mjs/caching/GenericCache.js"],"names":["isEmptyAccessToken","GenericCache","storage","updateFunctions","autoRenewInterval","autoRenewWindow","constructor","Map","setInterval","autoRenewRenewableItems","getOrCreate","cacheKey","createFunction","updateFunction","set","item","get","newCacheItem","Error","setCacheItem","asString","cachedItem","JSON","parse","itemDueToExpire","has","tryUpdateItem","expires","Date","now","remove","expiresOnAccess","value","expiresIn","cacheItem","stringify","forEach","key","updated","e","console","error"],"mappings":"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","sourcesContent":["import { isEmptyAccessToken } from \"../auth/IAuthStrategy.js\";\nexport default class GenericCache {\n    storage;\n    updateFunctions;\n    autoRenewInterval;\n    autoRenewWindow;\n    constructor(storage, updateFunctions = new Map(), autoRenewInterval = 0, autoRenewWindow = 2 * 60 * 1000 // Two minutes\n    ) {\n        this.storage = storage;\n        this.updateFunctions = updateFunctions;\n        this.autoRenewInterval = autoRenewInterval;\n        this.autoRenewWindow = autoRenewWindow;\n        if (this.autoRenewInterval > 0) {\n            setInterval(() => this.autoRenewRenewableItems(), this.autoRenewInterval);\n        }\n    }\n    async getOrCreate(cacheKey, createFunction, updateFunction) {\n        if (updateFunction) {\n            this.updateFunctions.set(cacheKey, updateFunction);\n        }\n        const item = await this.get(cacheKey);\n        if (item) {\n            return item;\n        }\n        const newCacheItem = await createFunction();\n        if (!newCacheItem) {\n            throw new Error(\"Could not create cache item\");\n        }\n        if (!isEmptyAccessToken(newCacheItem)) {\n            this.setCacheItem(cacheKey, newCacheItem);\n        }\n        return newCacheItem;\n    }\n    async get(cacheKey) {\n        let asString = this.storage.get(cacheKey);\n        let cachedItem = asString ? JSON.parse(asString) : null;\n        if (this.itemDueToExpire(cachedItem) && this.updateFunctions.has(cacheKey)) {\n            const updateFunction = this.updateFunctions.get(cacheKey);\n            await this.tryUpdateItem(cacheKey, cachedItem, updateFunction);\n            // Ensure updated item is returned\n            asString = this.storage.get(cacheKey);\n            cachedItem = asString ? JSON.parse(asString) : null;\n        }\n        if (!cachedItem) {\n            return null;\n        }\n        if (cachedItem.expires && (cachedItem.expires === -1 || cachedItem.expires <= Date.now())) {\n            this.remove(cacheKey);\n            return null;\n        }\n        if (cachedItem.expiresOnAccess && cachedItem.expiresOnAccess === true) {\n            this.remove(cacheKey);\n            return cachedItem;\n        }\n        return cachedItem;\n    }\n    set(cacheKey, value, expiresIn) {\n        const expires = Date.now() + expiresIn;\n        const cacheItem = { ...value, expires };\n        this.setCacheItem(cacheKey, cacheItem);\n    }\n    setCacheItem(cacheKey, cacheItem) {\n        const asString = JSON.stringify(cacheItem);\n        this.storage.set(cacheKey, asString);\n    }\n    remove(cacheKey) {\n        this.storage.remove(cacheKey);\n    }\n    itemDueToExpire(item) {\n        if (!item) {\n            return false;\n        }\n        if (!item.expires) {\n            return false;\n        }\n        return item.expires - Date.now() < (this.autoRenewWindow);\n    }\n    async autoRenewRenewableItems() {\n        this.updateFunctions.forEach(async (updateFunction, key) => {\n            const cachedItem = await this.get(key);\n            if (!cachedItem) {\n                return;\n            }\n            if (updateFunction && this.itemDueToExpire(cachedItem)) {\n                await this.tryUpdateItem(key, cachedItem, updateFunction);\n            }\n        });\n    }\n    async tryUpdateItem(key, cachedItem, updateFunction) {\n        try {\n            const updated = await updateFunction(cachedItem);\n            if (updated) {\n                this.setCacheItem(key, updated);\n            }\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}