{"ast":null,"code":"import _asyncToGenerator from \"/Users/kylenewins/Documents/The Moat/the_moat_io/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { Crypto } from \"./Crypto.js\";\nexport default class AccessTokenHelpers {\n  static refreshCachedAccessToken(clientId, item) {\n    return _asyncToGenerator(function* () {\n      const updated = yield AccessTokenHelpers.refreshToken(clientId, item.refresh_token);\n      return AccessTokenHelpers.toCachable(updated);\n    })();\n  }\n\n  static toCachable(item) {\n    if (item.expires && item.expires === -1) {\n      return item;\n    }\n\n    return { ...item,\n      expires: this.calculateExpiry(item)\n    };\n  }\n\n  static calculateExpiry(item) {\n    return Date.now() + item.expires_in * 1000;\n  }\n\n  static refreshToken(clientId, refreshToken) {\n    return _asyncToGenerator(function* () {\n      const params = new URLSearchParams();\n      params.append(\"client_id\", clientId);\n      params.append(\"grant_type\", \"refresh_token\");\n      params.append(\"refresh_token\", refreshToken);\n      const result = yield fetch(\"https://accounts.spotify.com/api/token\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\n        },\n        body: params\n      });\n      const text = yield result.text();\n\n      if (!result.ok) {\n        throw new Error(`Failed to refresh token: ${result.statusText}, ${text}`);\n      }\n\n      const json = JSON.parse(text);\n      return json;\n    })();\n  }\n\n  static generateCodeVerifier(length) {\n    let text = '';\n    let possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\n    for (let i = 0; i < length; i++) {\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n\n    return text;\n  }\n\n  static generateCodeChallenge(codeVerifier) {\n    return _asyncToGenerator(function* () {\n      const data = new TextEncoder().encode(codeVerifier);\n      const digest = yield Crypto.current.subtle.digest('SHA-256', data);\n      const digestBytes = [...new Uint8Array(digest)];\n      const hasBuffer = typeof Buffer !== 'undefined';\n      const digestAsBase64 = hasBuffer ? Buffer.from(digest).toString('base64') : btoa(String.fromCharCode.apply(null, digestBytes));\n      return digestAsBase64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n    })();\n  }\n\n}","map":{"version":3,"sources":["/Users/kylenewins/Documents/The Moat/the_moat_io/node_modules/@spotify/web-api-ts-sdk/dist/mjs/auth/AccessTokenHelpers.js"],"names":["Crypto","AccessTokenHelpers","refreshCachedAccessToken","clientId","item","updated","refreshToken","refresh_token","toCachable","expires","calculateExpiry","Date","now","expires_in","params","URLSearchParams","append","result","fetch","method","headers","body","text","ok","Error","statusText","json","JSON","parse","generateCodeVerifier","length","possible","i","charAt","Math","floor","random","generateCodeChallenge","codeVerifier","data","TextEncoder","encode","digest","current","subtle","digestBytes","Uint8Array","hasBuffer","Buffer","digestAsBase64","from","toString","btoa","String","fromCharCode","apply","replace"],"mappings":"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","sourcesContent":["import { Crypto } from \"./Crypto.js\";\nexport default class AccessTokenHelpers {\n    static async refreshCachedAccessToken(clientId, item) {\n        const updated = await AccessTokenHelpers.refreshToken(clientId, item.refresh_token);\n        return AccessTokenHelpers.toCachable(updated);\n    }\n    static toCachable(item) {\n        if (item.expires && item.expires === -1) {\n            return item;\n        }\n        return { ...item, expires: this.calculateExpiry(item) };\n    }\n    static calculateExpiry(item) {\n        return Date.now() + (item.expires_in * 1000);\n    }\n    static async refreshToken(clientId, refreshToken) {\n        const params = new URLSearchParams();\n        params.append(\"client_id\", clientId);\n        params.append(\"grant_type\", \"refresh_token\");\n        params.append(\"refresh_token\", refreshToken);\n        const result = await fetch(\"https://accounts.spotify.com/api/token\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n            body: params\n        });\n        const text = await result.text();\n        if (!result.ok) {\n            throw new Error(`Failed to refresh token: ${result.statusText}, ${text}`);\n        }\n        const json = JSON.parse(text);\n        return json;\n    }\n    static generateCodeVerifier(length) {\n        let text = '';\n        let possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        for (let i = 0; i < length; i++) {\n            text += possible.charAt(Math.floor(Math.random() * possible.length));\n        }\n        return text;\n    }\n    static async generateCodeChallenge(codeVerifier) {\n        const data = new TextEncoder().encode(codeVerifier);\n        const digest = await Crypto.current.subtle.digest('SHA-256', data);\n        const digestBytes = [...new Uint8Array(digest)];\n        const hasBuffer = typeof Buffer !== 'undefined';\n        const digestAsBase64 = hasBuffer\n            ? Buffer.from(digest).toString('base64')\n            : btoa(String.fromCharCode.apply(null, digestBytes));\n        return digestAsBase64\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_')\n            .replace(/=+$/, '');\n    }\n}\n"]},"metadata":{},"sourceType":"module"}