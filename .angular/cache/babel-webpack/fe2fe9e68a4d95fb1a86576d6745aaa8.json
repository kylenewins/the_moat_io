{"ast":null,"code":"import _asyncToGenerator from \"/Users/kylenewins/Documents/The Moat/the_moat_io/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport AccessTokenHelpers from \"./AccessTokenHelpers.js\";\nimport { emptyAccessToken } from \"./IAuthStrategy.js\";\nexport default class AuthorizationCodeWithPKCEStrategy {\n  clientId;\n  redirectUri;\n  scopes;\n  static cacheKey = \"spotify-sdk:AuthorizationCodeWithPKCEStrategy:token\";\n  configuration = null;\n\n  get cache() {\n    return this.configuration.cachingStrategy;\n  }\n\n  constructor(clientId, redirectUri, scopes) {\n    this.clientId = clientId;\n    this.redirectUri = redirectUri;\n    this.scopes = scopes;\n  }\n\n  setConfiguration(configuration) {\n    this.configuration = configuration;\n  }\n\n  getOrCreateAccessToken() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const token = yield _this.cache.getOrCreate(AuthorizationCodeWithPKCEStrategy.cacheKey, /*#__PURE__*/_asyncToGenerator(function* () {\n        const token = yield _this.redirectOrVerifyToken();\n        return AccessTokenHelpers.toCachable(token);\n      }), /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (expiring) {\n          return AccessTokenHelpers.refreshCachedAccessToken(_this.clientId, expiring);\n        });\n\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n      return token;\n    })();\n  }\n\n  getAccessToken() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const token = yield _this2.cache.get(AuthorizationCodeWithPKCEStrategy.cacheKey);\n      return token;\n    })();\n  }\n\n  removeAccessToken() {\n    this.cache.remove(AuthorizationCodeWithPKCEStrategy.cacheKey);\n  }\n\n  redirectOrVerifyToken() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const hashParams = new URLSearchParams(window.location.search);\n      const code = hashParams.get(\"code\");\n\n      if (code) {\n        const token = yield _this3.verifyAndExchangeCode(code);\n\n        _this3.removeCodeFromUrl();\n\n        return token;\n      }\n\n      _this3.redirectToSpotify();\n\n      return emptyAccessToken; // Redirected away at this point, just make TypeScript happy :)         \n    })();\n  }\n\n  redirectToSpotify() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const verifier = AccessTokenHelpers.generateCodeVerifier(128);\n      const challenge = yield AccessTokenHelpers.generateCodeChallenge(verifier);\n      const singleUseVerifier = {\n        verifier,\n        expiresOnAccess: true\n      };\n\n      _this4.cache.setCacheItem(\"spotify-sdk:verifier\", singleUseVerifier);\n\n      const redirectTarget = yield _this4.generateRedirectUrlForUser(_this4.scopes, challenge);\n      yield _this4.configuration.redirectionStrategy.redirect(redirectTarget);\n    })();\n  }\n\n  verifyAndExchangeCode(code) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const cachedItem = yield _this5.cache.get(\"spotify-sdk:verifier\");\n      const verifier = cachedItem?.verifier;\n\n      if (!verifier) {\n        throw new Error(\"No verifier found in cache - can't validate query string callback parameters.\");\n      }\n\n      yield _this5.configuration.redirectionStrategy.onReturnFromRedirect();\n      return yield _this5.exchangeCodeForToken(code, verifier);\n    })();\n  }\n\n  removeCodeFromUrl() {\n    const url = new URL(window.location.href);\n    url.searchParams.delete(\"code\");\n    const newUrl = url.search ? url.href : url.href.replace('?', '');\n    window.history.replaceState({}, document.title, newUrl);\n  }\n\n  generateRedirectUrlForUser(scopes, challenge) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const scope = scopes.join(' ');\n      const params = new URLSearchParams();\n      params.append(\"client_id\", _this6.clientId);\n      params.append(\"response_type\", \"code\");\n      params.append(\"redirect_uri\", _this6.redirectUri);\n      params.append(\"scope\", scope);\n      params.append(\"code_challenge_method\", \"S256\");\n      params.append(\"code_challenge\", challenge);\n      return `https://accounts.spotify.com/authorize?${params.toString()}`;\n    })();\n  }\n\n  exchangeCodeForToken(code, verifier) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const params = new URLSearchParams();\n      params.append(\"client_id\", _this7.clientId);\n      params.append(\"grant_type\", \"authorization_code\");\n      params.append(\"code\", code);\n      params.append(\"redirect_uri\", _this7.redirectUri);\n      params.append(\"code_verifier\", verifier);\n      const result = yield fetch(\"https://accounts.spotify.com/api/token\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\n        },\n        body: params\n      });\n      const text = yield result.text();\n\n      if (!result.ok) {\n        throw new Error(`Failed to exchange code for token: ${result.statusText}, ${text}`);\n      }\n\n      const json = JSON.parse(text);\n      return json;\n    })();\n  }\n\n} //# sourceMappingURL=AuthorizationCodeWithPKCEStrategy.js.map","map":null,"metadata":{},"sourceType":"module"}