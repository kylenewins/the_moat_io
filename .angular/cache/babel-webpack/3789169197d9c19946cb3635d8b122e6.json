{"ast":null,"code":"import _asyncToGenerator from \"/Users/kylenewins/Documents/The Moat/the_moat_io/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport AccessTokenHelpers from \"./AccessTokenHelpers.js\";\n/**\n * This strategy is used when you already have an access token and want to use it.\n * The authentication strategy will automatically renew the token when it expires.\n * Designed to allow a browser-based-app to post the access token to the server and use it from there.\n * @constructor\n * @param {string} clientId - Spotify application client id.\n * @param {string} accessToken - The access token returned from a client side Authorization Code with PKCE flow.\n */\n\nexport default class ProvidedAccessTokenStrategy {\n  clientId;\n  accessToken;\n  refreshTokenAction;\n\n  constructor(clientId, accessToken, refreshTokenAction) {\n    this.clientId = clientId;\n    this.accessToken = accessToken;\n    this.refreshTokenAction = refreshTokenAction || AccessTokenHelpers.refreshCachedAccessToken; // If the raw token from the jwt response is provided here\n    // Calculate an absolute `expiry` value.\n    // Caveat: If this token isn't fresh, this value will be off.\n    // It's the responsibility of the calling code to either set a valid\n    // expires property, or ensure expires_in accounts for any lag between\n    // issuing and passing here.\n\n    if (!this.accessToken.expires) {\n      this.accessToken.expires = AccessTokenHelpers.calculateExpiry(this.accessToken);\n    }\n  }\n\n  setConfiguration(_) {}\n\n  getOrCreateAccessToken() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.accessToken.expires && _this.accessToken.expires <= Date.now()) {\n        const refreshed = yield _this.refreshTokenAction(_this.clientId, _this.accessToken);\n        _this.accessToken = refreshed;\n      }\n\n      return _this.accessToken;\n    })();\n  }\n\n  getAccessToken() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this2.accessToken;\n    })();\n  }\n\n  removeAccessToken() {\n    this.accessToken = {\n      access_token: \"\",\n      token_type: \"\",\n      expires_in: 0,\n      refresh_token: \"\",\n      expires: 0\n    };\n  }\n\n}","map":{"version":3,"sources":["/Users/kylenewins/Documents/The Moat/the_moat_io/node_modules/@spotify/web-api-ts-sdk/dist/mjs/auth/ProvidedAccessTokenStrategy.js"],"names":["AccessTokenHelpers","ProvidedAccessTokenStrategy","clientId","accessToken","refreshTokenAction","constructor","refreshCachedAccessToken","expires","calculateExpiry","setConfiguration","_","getOrCreateAccessToken","Date","now","refreshed","getAccessToken","removeAccessToken","access_token","token_type","expires_in","refresh_token"],"mappings":";AAAA,OAAOA,kBAAP,MAA+B,yBAA/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,2BAAN,CAAkC;AAC7CC,EAAAA,QAAQ;AACRC,EAAAA,WAAW;AACXC,EAAAA,kBAAkB;;AAClBC,EAAAA,WAAW,CAACH,QAAD,EAAWC,WAAX,EAAwBC,kBAAxB,EAA4C;AACnD,SAAKF,QAAL,GAAgBA,QAAhB;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAKC,kBAAL,GAA0BA,kBAAkB,IAAIJ,kBAAkB,CAACM,wBAAnE,CAHmD,CAInD;AACA;AACA;AACA;AACA;AACA;;AACA,QAAI,CAAC,KAAKH,WAAL,CAAiBI,OAAtB,EAA+B;AAC3B,WAAKJ,WAAL,CAAiBI,OAAjB,GAA2BP,kBAAkB,CAACQ,eAAnB,CAAmC,KAAKL,WAAxC,CAA3B;AACH;AACJ;;AACDM,EAAAA,gBAAgB,CAACC,CAAD,EAAI,CACnB;;AACKC,EAAAA,sBAAsB,GAAG;AAAA;;AAAA;AAC3B,UAAI,KAAI,CAACR,WAAL,CAAiBI,OAAjB,IAA4B,KAAI,CAACJ,WAAL,CAAiBI,OAAjB,IAA4BK,IAAI,CAACC,GAAL,EAA5D,EAAwE;AACpE,cAAMC,SAAS,SAAS,KAAI,CAACV,kBAAL,CAAwB,KAAI,CAACF,QAA7B,EAAuC,KAAI,CAACC,WAA5C,CAAxB;AACA,QAAA,KAAI,CAACA,WAAL,GAAmBW,SAAnB;AACH;;AACD,aAAO,KAAI,CAACX,WAAZ;AAL2B;AAM9B;;AACKY,EAAAA,cAAc,GAAG;AAAA;;AAAA;AACnB,aAAO,MAAI,CAACZ,WAAZ;AADmB;AAEtB;;AACDa,EAAAA,iBAAiB,GAAG;AAChB,SAAKb,WAAL,GAAmB;AACfc,MAAAA,YAAY,EAAE,EADC;AAEfC,MAAAA,UAAU,EAAE,EAFG;AAGfC,MAAAA,UAAU,EAAE,CAHG;AAIfC,MAAAA,aAAa,EAAE,EAJA;AAKfb,MAAAA,OAAO,EAAE;AALM,KAAnB;AAOH;;AAtC4C","sourcesContent":["import AccessTokenHelpers from \"./AccessTokenHelpers.js\";\n/**\n * This strategy is used when you already have an access token and want to use it.\n * The authentication strategy will automatically renew the token when it expires.\n * Designed to allow a browser-based-app to post the access token to the server and use it from there.\n * @constructor\n * @param {string} clientId - Spotify application client id.\n * @param {string} accessToken - The access token returned from a client side Authorization Code with PKCE flow.\n */\nexport default class ProvidedAccessTokenStrategy {\n    clientId;\n    accessToken;\n    refreshTokenAction;\n    constructor(clientId, accessToken, refreshTokenAction) {\n        this.clientId = clientId;\n        this.accessToken = accessToken;\n        this.refreshTokenAction = refreshTokenAction || AccessTokenHelpers.refreshCachedAccessToken;\n        // If the raw token from the jwt response is provided here\n        // Calculate an absolute `expiry` value.\n        // Caveat: If this token isn't fresh, this value will be off.\n        // It's the responsibility of the calling code to either set a valid\n        // expires property, or ensure expires_in accounts for any lag between\n        // issuing and passing here.\n        if (!this.accessToken.expires) {\n            this.accessToken.expires = AccessTokenHelpers.calculateExpiry(this.accessToken);\n        }\n    }\n    setConfiguration(_) {\n    }\n    async getOrCreateAccessToken() {\n        if (this.accessToken.expires && this.accessToken.expires <= Date.now()) {\n            const refreshed = await this.refreshTokenAction(this.clientId, this.accessToken);\n            this.accessToken = refreshed;\n        }\n        return this.accessToken;\n    }\n    async getAccessToken() {\n        return this.accessToken;\n    }\n    removeAccessToken() {\n        this.accessToken = {\n            access_token: \"\",\n            token_type: \"\",\n            expires_in: 0,\n            refresh_token: \"\",\n            expires: 0\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}